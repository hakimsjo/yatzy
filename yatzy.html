<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎲 Yatzy 🎲</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #f0f4f8, #cdd5e0);
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #333;
        }

        .game-container {
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            text-align: center;
            max-width: 800px; /* Increased max-width to accommodate scorecard */
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 2.5em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .dice-section {
            width: 100%;
            margin-bottom: 30px;
        }

        .dice-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* Three equal columns */
            grid-template-rows: 1fr 1fr 1fr;    /* Three equal rows */
            width: 335px; /* Adjusted size for 50% larger dice */
            height: 335px; /* Make it square */
            gap: 10px; /* Small gap between grid cells */
            align-items: center; /* Center items vertically in their cells */
            justify-items: center; /* Center items horizontally in their cells */
            margin: 0 auto; /* Center the grid container itself */
            margin-bottom: 40px; /* Increased margin-bottom for more space */
        }

        .die {
            width: 105px; /* Adjusted size for 50% larger dice */
            height: 105px; /* Adjusted size for 50% larger dice */
            background-color: #ecf0f1;
            border: 4px solid #bdc3c7;
            border-radius: 15px;
            display: flex; /* Use flexbox for dot positioning */
            justify-content: center;
            align-items: center;
            position: relative; /* For absolute positioning of dots */
            font-size: 0; /* Hide the number */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            color: #34495e;
            user-select: none; /* Prevent text selection */
            padding: 15px; /* Padding inside the die for dots */
            box-sizing: border-box; /* Include padding in width/height */
        }

        /* Specific positioning for each die to form a '5' pattern */
        #die-0 { grid-area: 1 / 1; } /* Top-left */
        #die-1 { grid-area: 1 / 3; } /* Top-right */
        #die-2 { grid-area: 2 / 2; } /* Center */
        #die-3 { grid-area: 3 / 1; } /* Bottom-left */
        #die-4 { grid-area: 3 / 3; } /* Bottom-right */


        .die.held {
            background-color: #2ecc71;
            border-color: #27ae60;
            color: #ffffff;
            box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4);
            transform: translateY(-5px);
        }

        .die:hover:not(.held):not(.disabled) {
            background-color: #e0e6e9;
            transform: translateY(-3px);
        }

        .die.disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        /* Highlight for relevant dice on last roll (orange) */
        .die.highlight-last-roll {
            background-color: #f39c12; /* Orange color for highlight */
            border-color: #e67e22;
            color: white;
            box-shadow: 0 5px 20px rgba(243, 156, 18, 0.4);
            animation: pulse 1s infinite alternate; /* Optional: subtle pulse effect */
        }

        /* All dice turn blue on the final roll */
        .die.final-roll-blue {
            background: linear-gradient(45deg, #3498db, #2980b9); /* Blue gradient like roll button */
            border-color: #2980b9;
            color: white;
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
            opacity: 1 !important; /* Ensure it overrides .disabled opacity */
        }


        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }


        /* Animation for rolling dice */
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); opacity: 1; }
            25% { transform: rotate(90deg) scale(1.1); opacity: 0.8; }
            50% { transform: rotate(180deg) scale(1); opacity: 1; }
            75% { transform: rotate(270deg) scale(1.1); opacity: 0.8; }
            100% { transform: rotate(360deg) scale(1); opacity: 1; }
        }

        .die.rolling {
            animation: roll 0.5s ease-out;
        }

        .roll-info, .total-info {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #555;
            font-weight: bold;
        }
        .total-info {
            margin-top: 10px;
            margin-bottom: 25px;
            font-size: 1.4em;
            color: #2c3e50;
        }

        .button-container {
            display: flex;
            flex-direction: column; /* Stack button groups vertically */
            gap: 15px; /* Space between rows of buttons */
            margin-bottom: 20px;
        }

        .button-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button#rollButton {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        button#rollButton:hover:not(:disabled) {
            background: linear-gradient(45deg, #2980b9, #3498db);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.4);
        }

        button#rollButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        button#resetButton {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        button#resetButton:hover:not(:disabled) {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
        }

        button#helpButton {
            background: linear-gradient(45deg, #9b59b6, #8e44ad); /* Purple gradient */
            color: white;
        }

        button#helpButton:hover {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(155, 89, 182, 0.4);
        }

        button#soundToggleButton { /* New style for sound toggle button */
            background: linear-gradient(45deg, #6c757d, #495057); /* Greyish gradient */
            color: white;
        }

        button#soundToggleButton:hover {
            background: linear-gradient(45deg, #495057, #6c757d);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(108, 117, 125, 0.4);
        }


        .scorecard-section {
            width: 100%;
            max-width: 500px;
            margin-top: 30px;
            border: 2px solid #bdc3c7;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .scorecard-table th, .scorecard-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e6e9;
            text-align: left;
            font-size: 1em;
        }

        .scorecard-table th {
            background-color: #34495e;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scorecard-table tr:nth-child(even) {
            background-color: #f8fbfc;
        }

        .scorecard-table tr:hover:not(.total-row):not(.header-row) {
            background-color: #eef2f5;
        }

        .scorecard-table td:last-child, .scorecard-table th:last-child {
            text-align: right;
        }

        .category-name {
            font-weight: 600;
            color: #34495e;
        }

        .potential-score {
            font-style: italic;
            color: #7f8c8d;
        }

        .actual-score {
            font-weight: bold;
            color: #2c3e50;
        }

        .select-score-btn {
            background-color: #3498db;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            font-size: 0.9em;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .select-score-btn:hover:not(:disabled) {
            background-color: #2980b9;
            transform: translateY(-1px);
        }

        .select-score-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .total-row {
            background-color: #dbe4ed !important;
            font-weight: bold;
            color: #2c3e50;
        }

        .total-row td {
            border-top: 2px solid #bdc3c7;
        }

        .grand-total-row {
            background-color: #aebfd4 !important;
            font-weight: bold;
            font-size: 1.3em;
        }
        .grand-total-row td {
            border-top: 2px solid #7f8c8d;
        }

        /* Modal styles (shared for warning and help) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Changed to none */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
            display: flex; /* Added display: flex here */
        }

        .modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal-content {
            transform: translateY(0);
        }

        .modal-content h2 {
            color: #2c3e50; /* Changed to a neutral color for general modals */
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .modal-content p {
            font-size: 1.1em;
            color: #555;
            margin-bottom: 30px;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .modal-buttons button {
            padding: 12px 25px;
            font-size: 1.1em;
            border-radius: 8px;
            box-shadow: none;
            text-transform: none;
            letter-spacing: normal;
        }

        /* Specific styles for warning modal buttons */
        .modal-overlay#resetWarningModal .modal-content h2 {
            color: #e74c3c; /* Keep red for warning */
        }
        .modal-overlay#resetWarningModal .modal-buttons button.confirm-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .modal-overlay#resetWarningModal .modal-buttons button.confirm-btn:hover {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
        }

        .modal-overlay#resetWarningModal .modal-buttons button.cancel-btn {
            background-color: #bdc3c7;
            color: #34495e;
        }

        .modal-overlay#resetWarningModal .modal-buttons button.cancel-btn:hover {
            background-color: #95a5a6;
        }

        /* Specific styles for help modal buttons */
        .modal-overlay#helpModal .modal-buttons button.close-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }
        .modal-overlay#helpModal .modal-buttons button.close-btn:hover {
            background: linear-gradient(45deg, #2980b9, #3498db);
        }

        .credits {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-top: 20px;
        }

        /* Dot styling */
        .die .dot {
            position: absolute;
            width: 18%; /* Relative size of dots */
            height: 18%;
            background-color: #34495e; /* Dark dot color */
            border-radius: 50%;
            display: none; /* Hidden by default, shown by data-value classes */
        }

        /* Specific dot positions */
        .die .dot-center { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .die .dot-tl { top: 15%; left: 15%; }
        .die .dot-tr { top: 15%; right: 15%; }
        .die .dot-bl { bottom: 15%; left: 15%; }
        .die .dot-br { bottom: 15%; right: 15%; }
        .die .dot-ml { top: 50%; left: 15%; transform: translateY(-50%); } /* Middle-left for 6 */
        .die .dot-mr { top: 50%; right: 15%; transform: translateY(-50%); } /* Middle-right for 6 */

        /* Show dots based on data-value attribute */
        .die[data-value="1"] .dot-center { display: block; }

        .die[data-value="2"] .dot-tl,
        .die[data-value="2"] .dot-br { display: block; }

        .die[data-value="3"] .dot-tl,
        .die[data-value="3"] .dot-center,
        .die[data-value="3"] .dot-br { display: block; }

        .die[data-value="4"] .dot-tl,
        .die[data-value="4"] .dot-tr,
        .die[data-value="4"] .dot-bl,
        .die[data-value="4"] .dot-br { display: block; }

        .die[data-value="5"] .dot-tl,
        .die[data-value="5"] .dot-tr,
        .die[data-value="5"] .dot-center,
        .die[data-value="5"] .dot-bl,
        .die[data-value="5"] .dot-br { display: block; }

        .die[data-value="6"] .dot-tl,
        .die[data-value="6"] .dot-tr,
        .die[data-value="6"] .dot-ml,
        .die[data-value="6"] .dot-mr,
        .die[data-value="6"] .dot-bl,
        .die[data-value="6"] .dot-br { display: block; }


        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
            }
            h1 {
                font-size: 2em;
            }
            .dice-container {
                width: 245px; /* Adjusted for 50% larger dice on smaller screens */
                height: 245px;
                margin-bottom: 30px; /* Adjusted margin for smaller screens */
            }
            .die {
                width: 75px; /* Adjusted for 50% larger dice on smaller screens */
                height: 75px;
                font-size: 3em; /* Adjusted font size */
                padding: 10px; /* Adjusted padding for smaller dice */
            }
            button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .scorecard-table th, .scorecard-table td {
                padding: 10px;
                font-size: 0.9em;
            }
            .select-score-btn {
                padding: 6px 10px;
                font-size: 0.8em;
            }
            .modal-content {
                padding: 20px;
            }
            .modal-content h2 {
                font-size: 1.5em;
            }
            .modal-content p {
                font-size: 1em;
            }
            .modal-buttons button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .dice-container {
                width: 200px; /* Adjusted for 50% larger dice on very small screens */
                height: 200px;
                margin-bottom: 25px; /* Adjusted margin for very small screens */
            }
            .die {
                width: 60px; /* Adjusted for 50% larger dice on very small screens */
                height: 60px;
                font-size: 2.25em; /* Adjusted font size */
                padding: 8px; /* Adjusted padding for smaller dice */
            }
            .button-container {
                flex-direction: column;
                gap: 10px;
            }
            .button-row {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>🎲 Yatzy 🎲</h1>
        <div class="dice-section">
            <div class="dice-container" id="diceContainer">
                <!-- Dice will be rendered here by JavaScript -->
                <div class="die" id="die-0">
                    <div class="dot dot-tl"></div>
                    <div class="dot dot-tr"></div>
                    <div class="dot dot-ml"></div>
                    <div class="dot dot-center"></div> <!-- Corrected class name -->
                    <div class="dot dot-mr"></div>
                    <div class="dot dot-bl"></div>
                    <div class="dot dot-br"></div>
                </div>
                <div class="die" id="die-1">
                    <div class="dot dot-tl"></div>
                    <div class="dot dot-tr"></div>
                    <div class="dot dot-ml"></div>
                    <div class="dot dot-center"></div> <!-- Corrected class name -->
                    <div class="dot dot-mr"></div>
                    <div class="dot dot-bl"></div>
                    <div class="dot dot-br"></div>
                </div>
                <div class="die" id="die-2">
                    <div class="dot dot-tl"></div>
                    <div class="dot dot-tr"></div>
                    <div class="dot dot-ml"></div>
                    <div class="dot dot-center"></div> <!-- Corrected class name -->
                    <div class="dot dot-mr"></div>
                    <div class="dot dot-bl"></div>
                    <div class="dot dot-br"></div>
                </div>
                <div class="die" id="die-3">
                    <div class="dot dot-tl"></div>
                    <div class="dot dot-tr"></div>
                    <div class="dot dot-ml"></div>
                    <div class="dot dot-center"></div> <!-- Corrected class name -->
                    <div class="dot dot-mr"></div>
                    <div class="dot dot-bl"></div>
                    <div class="dot dot-br"></div>
                </div>
                <div class="die" id="die-4">
                    <div class="dot dot-tl"></div>
                    <div class="dot dot-tr"></div>
                    <div class="dot dot-ml"></div>
                    <div class="dot dot-center"></div> <!-- Corrected class name -->
                    <div class="dot dot-mr"></div>
                    <div class="dot dot-bl"></div>
                    <div class="dot dot-br"></div>
                </div>
            </div>
            <div class="roll-info">
                <p>Kast kvar: <span id="rollsLeft">3</span></p>
            </div>
            <div class="total-info">
                <p>Aktuell Totalsumma: <span id="currentRollTotal">0</span></p>
            </div>
            <div class="button-container">
                <div class="button-row">
                    <button id="rollButton">🎲 Kasta tärningar</button>
                    <button id="resetButton">🔄 Nytt spel</button>
                </div>
                <div class="button-row">
                    <button id="helpButton">❓ Hjälp</button>
                    <button id="soundToggleButton">🔊 Ljud på</button>
                </div>
            </div>
        </div>

        <div class="scorecard-section">
            <table class="scorecard-table">
                <thead>
                    <tr class="header-row">
                        <th>Kategori</th>
                        <th>Poäng</th>
                        <th>Välj</th>
                    </tr>
                </thead>
                <tbody id="scorecardBody">
                    <!-- Upper Section -->
                    <tr data-category="ones">
                        <td class="category-name">Ettor (5)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="ones">Välj</button></td>
                    </tr>
                    <tr data-category="twos">
                        <td class="category-name">Tvåor (10)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="twos">Välj</button></td>
                    </tr>
                    <tr data-category="threes">
                        <td class="category-name">Treor (15)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="threes">Välj</button></td>
                    </tr>
                    <tr data-category="fours">
                        <td class="category-name">Fyror (20)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="fours">Välj</button></td>
                    </tr>
                    <tr data-category="fives">
                        <td class="category-name">Femmor (25)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="fives">Välj</button></td>
                    </tr>
                    <tr data-category="sixes">
                        <td class="category-name">Sexor (30)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="sixes">Välj</button></td>
                    </tr>
                    <tr class="total-row">
                        <td class="category-name">Summa</td>
                        <td id="upperSum">0</td>
                        <td></td>
                    </tr>
                    <tr class="total-row">
                        <td class="category-name">Bonus (63+)</td>
                        <td id="upperBonus">0</td>
                        <td></td>
                    </tr>
                    <tr class="total-row">
                        <td class="category-name">Övre Total</td>
                        <td id="upperTotal">0</td>
                        <td></td>
                    </tr>

                    <!-- Lower Section -->
                    <tr data-category="onePair">
                        <td class="category-name">Ett par (12)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="onePair">Välj</button></td>
                    </tr>
                    <tr data-category="twoPair">
                        <td class="category-name">Två par (22)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="twoPair">Välj</button></td>
                    </tr>
                    <tr data-category="threeOfAKind">
                        <td class="category-name">Triss (18)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="threeOfAKind">Välj</button></td>
                    </tr>
                    <tr data-category="fourOfAKind">
                        <td class="category-name">Fyrtal (24)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="fourOfAKind">Välj</button></td>
                    </tr>
                    <tr data-category="fullHouse">
                        <td class="category-name">Kåk (28)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="fullHouse">Välj</button></td>
                    </tr>
                    <tr data-category="smallStraight">
                        <td class="category-name">Liten stege (15)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="smallStraight">Välj</button></td>
                    </tr>
                    <tr data-category="largeStraight">
                        <td class="category-name">Stor stege (20)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="largeStraight">Välj</button></td>
                    </tr>
                    <tr data-category="yatzy">
                        <td class="category-name">Yatzy (50)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="yatzy">Välj</button></td>
                    </tr>
                    <tr data-category="chance">
                        <td class="category-name">Chans (30)</td>
                        <td class="score-cell"><span class="potential-score"></span><span class="actual-score"></span></td>
                        <td><button class="select-score-btn" data-category="chance">Välj</button></td>
                    </tr>
                    <tr class="total-row">
                        <td class="category-name">Nedre Total</td>
                        <td id="lowerTotal">0</td>
                        <td></td>
                    </tr>
                    <tr class="grand-total-row">
                        <td class="category-name">Total Poäng</td>
                        <td id="grandTotal">0</td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="credits">
            by <a href="https://github.com/hakimsjo/yatzy" target="_blank" rel="noopener noreferrer">Hakim</a> & Gemini
        </div>
    </div>

    <!-- Warning Modal -->
    <div class="modal-overlay" id="resetWarningModal">
        <div class="modal-content">
            <h2>Starta nytt spel?</h2>
            <p>Är du säker på att du vill starta ett nytt spel? Alla dina nuvarande poäng kommer att raderas.</p>
            <div class="modal-buttons">
                <button class="confirm-btn" id="confirmResetButton">✅ Ja, starta nytt</button>
                <button class="cancel-btn" id="cancelResetButton">❌ Nej, fortsätt spela</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <h2>ℹ️ Hjälp</h2>
            <p>Alla spelare bör ha denna på sin mobil för att vara med och spela. Slå ditt slag och välj vilka tärningar du vill spara. När du kastat dina tre kast så lägg in poängen i tabellen genom att klicka på välj. Spelet visar vilka val som är möjliga. När du valt är det nästa spelare att göra desamma. Gör detta tills det inte finns några möjliga val. Vill man ha mer information eller om man man bara vill ha digitala tärningar kan man använda yatzy tärning versionen som finns på <a href="https://github.com/hakimsjo/yatzy" target="_blank" rel="noopener noreferrer">github</a>.</p>
            <div class="modal-buttons">
                <button class="close-btn" id="closeHelpButton">✖️ Stäng</button>
            </div>
        </div>
    </div>

    <script>
        // Game state variables
        let dice = [1, 1, 1, 1, 1]; // Current values of the five dice
        let heldDice = [false, false, false, false, false]; // Which dice are held
        let rollsMade = 0; // Number of rolls in current round
        const maxRolls = 3; // Maximum rolls per round
        let isSoundOn = true; // State for sound toggle
        let audioContext = null; // Global AudioContext instance

        // New Yatzy bonus tracking
        let totalYatzysClaimed = 0; // Counts total Yatzys (up to 3)

        // Scorecard state
        const scorecard = {
            // Upper Section Categories
            ones: { value: 0, isFilled: false },
            twos: { value: 0, isFilled: false },
            threes: { value: 0, isFilled: false },
            fours: { value: 0, isFilled: false },
            fives: { value: 0, isFilled: false },
            sixes: { value: 0, isFilled: false },
            // Lower Section Categories
            onePair: { value: 0, isFilled: false },
            twoPair: { value: 0, isFilled: false },
            threeOfAKind: { value: 0, isFilled: false },
            fourOfAKind: { value: 0, isFilled: false },
            fullHouse: { value: 0, isFilled: false },
            smallStraight: { value: 0, isFilled: false },
            largeStraight: { value: 0, isFilled: false },
            yatzy: { value: 0, isFilled: false }, // This will now accumulate all Yatzy scores
            chance: { value: 0, isFilled: false }
        };

        let upperSum = 0;
        let upperBonus = 0;
        let upperTotalScore = 0;
        let lowerTotalScore = 0;
        let grandTotalScore = 0;

        // Get references to HTML elements
        const diceContainer = document.getElementById('diceContainer');
        const rollsLeftSpan = document.getElementById('rollsLeft');
        const currentRollTotalSpan = document.getElementById('currentRollTotal');
        const rollButton = document.getElementById('rollButton');
        const resetButton = document.getElementById('resetButton');
        const helpButton = document.getElementById('helpButton');
        const soundToggleButton = document.getElementById('soundToggleButton');

        const scorecardBody = document.getElementById('scorecardBody');
        const upperSumElement = document.getElementById('upperSum');
        const upperBonusElement = document.getElementById('upperBonus');
        const upperTotalElement = document.getElementById('upperTotal');
        const lowerTotalElement = document.getElementById('lowerTotal');
        const grandTotalElement = document.getElementById('grandTotal');

        // Modal elements
        const resetWarningModal = document.getElementById('resetWarningModal');
        const confirmResetButton = document.getElementById('confirmResetButton');
        const cancelResetButton = document.getElementById('cancelResetButton');
        const helpModal = document.getElementById('helpModal');
        const closeHelpButton = document.getElementById('closeHelpButton');

        // Global array to store references to the static die elements
        const dieElements = [];


        /**
         * Counts the occurrences of each die value.
         * @param {Array<number>} diceValues - An array of die values.
         * @returns {Object} An object where keys are die values and values are their counts.
         */
        function getCounts(diceValues) {
            const counts = {};
            diceValues.forEach(die => {
                counts[die] = (counts[die] || 0) + 1;
            });
            return counts;
        }

        /**
         * Calculates the score for a given Yatzy category based on the current dice.
         * @param {string} categoryName - The name of the category (e.g., 'ones', 'fullHouse').
         * @param {Array<number>} currentDice - The array of current die values.
         * @returns {number} The calculated score for the category.
         */
        function calculateCategoryScore(categoryName, currentDice) {
            const counts = getCounts(currentDice);
            const sortedDice = [...currentDice].sort((a, b) => a - b);
            let score = 0;

            // Define a map for upper section categories to their numeric values
            const upperSectionValueMap = {
                'ones': 1,
                'twos': 2,
                'threes': 3,
                'fours': 4,
                'fives': 5,
                'sixes': 6
            };

            // Check if the category is in the upper section
            if (upperSectionValueMap.hasOwnProperty(categoryName)) {
                const value = upperSectionValueMap[categoryName];
                score = (counts[value] || 0) * value;
            } else {
                // Handle lower section categories
                switch (categoryName) {
                    case 'onePair':
                        const pairsFoundOnePair = Object.keys(counts).filter(dieValue => counts[dieValue] >= 2).map(Number);
                        if (pairsFoundOnePair.length > 0) {
                            const highestPairValue = Math.max(...pairsFoundOnePair);
                            score = highestPairValue * 2;
                        }
                        break;
                    case 'twoPair':
                        const pairsFoundTwoPair = Object.keys(counts).filter(dieValue => counts[dieValue] >= 2).map(Number);
                        pairsFoundTwoPair.sort((a, b) => b - a);

                        if (pairsFoundTwoPair.length >= 2 && pairsFoundTwoPair[0] !== pairsFoundTwoPair[1]) {
                            score = (pairsFoundTwoPair[0] * 2) + (pairsFoundTwoPair[1] * 2);
                        } else if (pairsFoundTwoPair.length >= 3 && pairsFoundTwoPair[0] === pairsFoundTwoPair[1]) {
                            // Case like [6,6,6,5,5] where we can take two pairs (6+6 and 5+5)
                            score = (pairsFoundTwoPair[0] * 2) + (pairsFoundTwoPair[1] * 2);
                        }
                        break;
                    case 'threeOfAKind':
                        // Sum of the three dice forming the triss
                        const threeOfAKindValue = Object.keys(counts).find(dieValue => counts[dieValue] >= 3);
                        if (threeOfAKindValue) {
                            score = parseInt(threeOfAKindValue) * 3;
                        }
                        break;
                    case 'fourOfAKind':
                        // Sum of the four dice forming the fyrtal
                        const fourOfAKindValue = Object.keys(counts).find(dieValue => counts[dieValue] >= 4);
                        if (fourOfAKindValue) {
                            score = parseInt(fourOfAKindValue) * 4;
                        }
                        break;
                    case 'fullHouse':
                        const hasThree = Object.keys(counts).find(dieValue => counts[dieValue] === 3);
                        const hasTwo = Object.keys(counts).find(dieValue => counts[dieValue] === 2);
                        if (hasThree && hasTwo) {
                            score = (parseInt(hasThree) * 3) + (parseInt(hasTwo) * 2);
                        }
                        break;
                    case 'smallStraight':
                        const uniqueDice = [...new Set(sortedDice)];
                        // Check for 1-2-3-4-5 or 2-3-4-5-6
                        const isSmallStraight = (uniqueDice.includes(1) && uniqueDice.includes(2) && uniqueDice.includes(3) && uniqueDice.includes(4)) ||
                                                (uniqueDice.includes(2) && uniqueDice.includes(3) && uniqueDice.includes(4) && uniqueDice.includes(5)) ||
                                                (uniqueDice.includes(3) && uniqueDice.includes(4) && uniqueDice.includes(5) && uniqueDice.includes(6));
                        if (isSmallStraight) {
                            score = 15; // Fixed 15 points for small straight
                        }
                        break;
                    case 'largeStraight':
                        // Check if the sorted dice exactly match a large straight pattern
                        const isLargeStraight1 = sortedDice.every((val, i) => val === (i + 1)); // 1,2,3,4,5
                        const isLargeStraight2 = sortedDice.every((val, i) => val === (i + 2)); // 2,3,4,5,6
                        if (isLargeStraight1 || isLargeStraight2) {
                            score = 20; // Fixed 20 points for large straight
                        }
                        break;
                    case 'yatzy':
                        if (Object.values(counts).some(count => count === 5)) {
                            if (totalYatzysClaimed < 3) {
                                score = 50; // Always 50 for a Yatzy, up to 3 times
                            } else {
                                score = 0; // Already claimed 3 Yatzys, no more points
                            }
                        }
                        break;
                    case 'chance':
                        score = currentDice.reduce((sum, val) => sum + val, 0);
                        break;
                    default:
                        score = 0;
                }
            }
            return score;
        }

        /**
         * Renders the dice on the screen and updates roll info.
         * @param {boolean} [isInitialRender=false] - True if this is the very first render of the game.
         */
        function renderDice(isInitialRender = false) {
            // No innerHTML = '' here as elements are static
            dice.forEach((value, index) => {
                const dieElement = dieElements[index]; // Get the pre-existing element

                // Clear all dynamic classes before applying new ones
                dieElement.classList.remove('held', 'disabled', 'highlight-last-roll', 'rolling', 'final-roll-blue');

                if (heldDice[index]) {
                    dieElement.classList.add('held');
                }
                // Disable dice toggling if no rolls have been made yet (start of game/new round)
                // or if max rolls are reached and the roll button is disabled (score needs to be chosen).
                if (isInitialRender || (rollsMade >= maxRolls && rollButton.disabled)) {
                     dieElement.classList.add('disabled');
                }

                // New: All dice turn blue on the final roll
                if (rollsMade === maxRolls) {
                    dieElement.classList.add('final-roll-blue');
                }
                // Original highlight logic for last roll (orange) - now only applies if not final-roll-blue
                // This block is effectively overridden by the 'final-roll-blue' class if rollsMade === maxRolls
                // However, keeping it for clarity of previous logic.
                if (rollsMade === maxRolls && !isInitialRender && !dieElement.classList.contains('final-roll-blue')) {
                    const dieValue = parseInt(value);
                    const upperSectionValueMap = {
                        'ones': 1, 'twos': 2, 'threes': 3,
                        'fours': 4, 'fives': 5, 'sixes': 6
                    };

                    const categoryName = Object.keys(upperSectionValueMap).find(key => upperSectionValueMap[key] === dieValue);

                    if (categoryName && !scorecard[categoryName].isFilled) {
                        dieElement.classList.add('highlight-last-roll');
                    }
                }

                // Set the data-value attribute to control dot visibility via CSS
                dieElement.setAttribute('data-value', value);
                // Event listener is now added once in DOMContentLoaded, no need to add here
            });
            rollsLeftSpan.textContent = maxRolls - rollsMade;
            currentRollTotalSpan.textContent = calculateTotal(dice);
            // Enable/disable roll button based on rolls left AND if scorecard is not full
            rollButton.disabled = (rollsMade >= maxRolls || isScorecardFull());

            updateScorecardUI(); // Always update scorecard when dice are rendered
        }

        /**
         * Toggles the held status of a specific die.
         * @param {number} index - The index of the die to toggle (0-4).
         */
        function toggleHold(index) {
            // Only allow toggling if at least one roll has been made AND
            // (there are rolls left OR the roll button is not disabled, meaning a score hasn't been forced yet)
            // AND if the scorecard is not yet full AND it's not the final roll (where all dice are blue/locked)
            if (rollsMade > 0 && (rollsMade < maxRolls || (rollsMade === maxRolls && !rollButton.disabled)) && !isScorecardFull() && rollsMade < maxRolls) {
                heldDice[index] = !heldDice[index];
                renderDice();
            }
        }

        /**
         * Rolls the dice that are not currently held.
         * Adds a rolling animation to the dice.
         * Updates the roll counter and re-renders the dice.
         */
        function rollDice() {
            // Only allow rolling if the scorecard is not full
            if (rollsMade < maxRolls && !isScorecardFull()) {
                const dieElementsToRoll = dieElements.filter((_, index) => !heldDice[index]);
                dieElementsToRoll.forEach(dieElement => {
                    dieElement.classList.add('rolling');
                });

                // Play sound if enabled
                playDiceSound();

                // Disable roll button temporarily during animation
                rollButton.disabled = true;

                setTimeout(() => {
                    dice.forEach((value, index) => {
                        if (!heldDice[index]) {
                            dice[index] = Math.floor(Math.random() * 6) + 1;
                        }
                    });
                    rollsMade++;
                    renderDice(); // Re-render to show new values and update totals

                    // Remove rolling animation class after rendering
                    dieElementsToRoll.forEach((dieElement) => {
                        dieElement.classList.remove('rolling');
                    });

                    // Re-enable roll button if rolls are left and scorecard is not full,
                    // otherwise keep disabled until score is chosen or game ends
                    if (rollsMade < maxRolls) {
                        rollButton.disabled = false;
                    } else {
                        rollButton.disabled = true; // Max rolls reached or scorecard full
                    }
                }, 500); // Animation duration
            }
        }

        /**
         * Calculates the sum of all dice values.
         * @returns {number} The total sum of the dice.
         */
        function calculateTotal(diceValues) {
            return diceValues.reduce((sum, value) => sum + value, 0);
        }

        /**
         * Checks if all categories in the scorecard are filled.
         * @returns {boolean} True if all categories are filled, false otherwise.
         */
        function isScorecardFull() {
            for (const category in scorecard) {
                if (!scorecard[category].isFilled) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Updates the scorecard UI with potential and actual scores.
         * Enables/disables "Välj" buttons based on category status.
         */
        function updateScorecardUI() {
            let currentUpperSum = 0;
            let currentLowerSum = 0;

            for (const category in scorecard) {
                const rowElement = scorecardBody.querySelector(`[data-category="${category}"]`);
                if (!rowElement) continue; // Skip if row not found

                const potentialScoreSpan = rowElement.querySelector('.potential-score');
                const actualScoreSpan = rowElement.querySelector('.actual-score');
                const selectButton = rowElement.querySelector('.select-score-btn');

                if (category === 'yatzy') {
                    const currentYatzyPotential = calculateCategoryScore('yatzy', dice);
                    if (totalYatzysClaimed >= 3) {
                        potentialScoreSpan.textContent = '';
                        actualScoreSpan.textContent = scorecard.yatzy.value;
                        selectButton.disabled = true;
                        selectButton.textContent = 'Max Yatzy';
                        selectButton.style.backgroundColor = '#cccccc';
                    } else if (scorecard.yatzy.isFilled) { // If first Yatzy is already claimed
                        potentialScoreSpan.textContent = currentYatzyPotential > 0 ? `(${currentYatzyPotential})` : '';
                        actualScoreSpan.textContent = scorecard.yatzy.value;
                        selectButton.disabled = (rollsMade === 0 || currentYatzyPotential === 0); // Only enable if Yatzy is rolled
                        selectButton.textContent = 'Välj Bonus';
                        selectButton.style.backgroundColor = '#f39c12'; // Orange for bonus selection
                    } else { // First Yatzy not claimed yet
                        potentialScoreSpan.textContent = currentYatzyPotential > 0 ? `(${currentYatzyPotential})` : '';
                        actualScoreSpan.textContent = scorecard.yatzy.value;
                        selectButton.disabled = (rollsMade === 0 || currentYatzyPotential === 0);
                        selectButton.textContent = 'Välj';
                        selectButton.style.backgroundColor = '#3498db';
                    }
                } else { // For all other categories
                    if (scorecard[category].isFilled) {
                        potentialScoreSpan.textContent = '';
                        actualScoreSpan.textContent = scorecard[category].value;
                        selectButton.disabled = true;
                        selectButton.textContent = 'Vald';
                        selectButton.style.backgroundColor = '#27ae60'; // Green for selected
                    } else {
                        potentialScoreSpan.textContent = `(${calculateCategoryScore(category, dice)})`;
                        actualScoreSpan.textContent = '';
                        selectButton.disabled = (rollsMade === 0 || isScorecardFull());
                        selectButton.textContent = 'Välj';
                        selectButton.style.backgroundColor = '#3498db';
                    }
                }


                // Sum up scores for totals (only if filled, as per original logic)
                if (scorecard[category].isFilled) {
                    if (['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'].includes(category)) {
                        currentUpperSum += scorecard[category].value;
                    } else if (category !== 'yatzy') { // Exclude Yatzy from lowerSum for now, it's handled separately
                        currentLowerSum += scorecard[category].value;
                    }
                }
            }

            // Update Upper Section Totals
            upperSum = currentUpperSum;
            upperSumElement.textContent = upperSum;

            upperBonus = (upperSum >= 63) ? 35 : 0;
            upperBonusElement.textContent = upperBonus;

            upperTotalScore = upperSum + upperBonus;
            upperTotalElement.textContent = upperTotalScore;

            // Update Lower Section Total (excluding the main Yatzy score, which is now part of grandTotal)
            // The main Yatzy score (50) is part of scorecard.yatzy.value.
            // We need to add all filled lower section categories *except* the main Yatzy score
            // to lowerTotalScore, and then add the full scorecard.yatzy.value to grandTotal.
            lowerTotalScore = 0;
            for (const category in scorecard) {
                if (scorecard[category].isFilled && !['ones', 'twos', 'threes', 'fours', 'fives', 'sixes', 'yatzy'].includes(category)) {
                    lowerTotalScore += scorecard[category].value;
                }
            }
            lowerTotalElement.textContent = lowerTotalScore;

            // Update Grand Total - includes upper total, lower total (excluding Yatzy), and all Yatzy points
            grandTotalScore = upperTotalScore + lowerTotalScore + scorecard.yatzy.value;
            grandTotalElement.textContent = grandTotalScore;
        }

        /**
         * Handles selecting a score for a category.
         * @param {string} categoryName - The name of the category to select.
         */
        function selectScore(categoryName) {
            // Prevent re-selecting already filled categories (except for Yatzy bonus scenario)
            if (scorecard[categoryName].isFilled && categoryName !== 'yatzy') {
                console.log(`Kategori ${categoryName} är redan vald.`);
                return;
            }

            const calculatedScore = calculateCategoryScore(categoryName, dice);

            if (categoryName === 'yatzy') {
                if (calculatedScore === 50 && totalYatzysClaimed < 3) { // Check if it's a Yatzy roll and limit not reached
                    scorecard.yatzy.value += 50; // Add 50 points
                    scorecard.yatzy.isFilled = true; // Mark as filled after first claim
                    totalYatzysClaimed++;
                } else {
                    console.log("Kan inte välja Yatzy: Ingen Yatzy rullad eller max antal Yatzys redan valda.");
                    return; // Do not reset round if selection was invalid
                }
            } else { // For all other categories
                scorecard[categoryName].value = calculatedScore;
                scorecard[categoryName].isFilled = true;
            }

            // Reset for next round if a valid score was selected and scorecard is not full
            if (!isScorecardFull()) {
                dice = [1, 1, 1, 1, 1];
                heldDice = [false, false, false, false, false];
                rollsMade = 0;
                rollButton.disabled = false; // Enable roll button for new round
            } else {
                rollButton.disabled = true; // Keep disabled if scorecard is full
            }

            renderDice(); // Re-render dice and scorecard
        }

        /**
         * Resets the entire game to its initial state.
         */
        function resetGame() {
            // Reset dice and roll counter
            dice = [1, 1, 1, 1, 1];
            heldDice = [false, false, false, false, false];
            rollsMade = 0;

            // Reset Yatzy bonus tracking
            totalYatzysClaimed = 0;

            // Reset scorecard
            for (const category in scorecard) {
                scorecard[category].value = 0;
                scorecard[category].isFilled = false;
            }

            // Reset totals
            upperSum = 0;
            upperBonus = 0;
            upperTotalScore = 0;
            lowerTotalScore = 0;
            grandTotalScore = 0;

            renderDice(true); // Initial render to disable dice
            rollButton.disabled = false; // Ensure roll button is enabled
        }

        // --- Modal Functions ---
        /**
         * Displays the reset warning modal.
         */
        function showResetWarning() {
            resetWarningModal.classList.add('visible');
        }

        /**
         * Hides the reset warning modal.
         */
        function hideResetWarning() {
            resetWarningModal.classList.remove('visible');
        }

        /**
         * Displays the help modal.
         */
        function showHelpModal() {
            helpModal.classList.add('visible');
        }

        /**
         * Hides the help modal.
         */
        function hideHelpModal() {
            helpModal.classList.remove('visible');
        }

        /**
         * Plays a "shaking dices" sound using Web Audio API.
         */
        function playDiceSound() {
            if (!isSoundOn) return;

            // Initialize AudioContext if it hasn't been already
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Resume context if it's suspended (common on mobile)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log("AudioContext resumed successfully.");
                    _generateAndPlayDiceSound(); // Play sound after resuming
                }).catch(e => console.error("Error resuming AudioContext:", e));
            } else {
                _generateAndPlayDiceSound(); // Play sound directly if context is running
            }
        }

        /**
         * Internal function to generate and play the dice sound.
         * Assumes audioContext is already initialized and resumed if necessary.
         */
        function _generateAndPlayDiceSound() {
            try {
                const duration = 0.5; // Total duration of the shaking sound
                const numClicks = 8; // Number of individual "clicks"
                const clickDuration = 0.05; // Duration of each click

                for (let i = 0; i < numClicks; i++) {
                    const startTime = audioContext.currentTime + (i * (duration / numClicks));

                    // Create a short burst of white noise for the "click"
                    const bufferSize = audioContext.sampleRate * clickDuration;
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let j = 0; j < bufferSize; j++) {
                        output[j] = Math.random() * 0.8 - 0.4; // Slightly lower amplitude noise
                    }

                    const noiseSource = audioContext.createBufferSource();
                    noiseSource.buffer = noiseBuffer;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.4 + Math.random() * 0.2, startTime + 0.01); // Quick attack with slight randomness
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + clickDuration); // Fast decay

                    noiseSource.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    noiseSource.start(startTime);
                    noiseSource.stop(startTime + clickDuration);
                }

            } catch (e) {
                console.error("Failed to generate and play sound:", e);
            }
        }

        /**
         * Toggles the sound on/off and updates the button text.
         */
        function toggleSound() {
            isSoundOn = !isSoundOn;
            soundToggleButton.textContent = isSoundOn ? '🔊 Ljud på' : '🔇 Ljud av';

            // Attempt to initialize/resume AudioContext when sound is turned on
            if (isSoundOn && !audioContext) {
                playDiceSound(); // This will create and attempt to resume the context
            } else if (!isSoundOn && audioContext && audioContext.state === 'running') {
                // If turning sound off and context is running, suspend it
                audioContext.suspend().then(() => {
                    console.log("AudioContext suspended successfully.");
                }).catch(e => console.error("Error suspending AudioContext:", e));
            }
        }


        // --- Event Listeners ---
        // Add event listener to "Välj" buttons using event delegation
        scorecardBody.addEventListener('click', (event) => {
            if (event.target.classList.contains('select-score-btn')) {
                const category = event.target.dataset.category;
                selectScore(category);
            }
        });

        // Add event listeners to main buttons
        rollButton.addEventListener('click', rollDice);

        // Modified resetButton listener to show warning modal
        resetButton.addEventListener('click', showResetWarning);

        // New: Help button listener
        helpButton.addEventListener('click', showHelpModal);

        // New: Sound toggle button listener
        soundToggleButton.addEventListener('click', toggleSound);

        // Modal button listeners
        confirmResetButton.addEventListener('click', () => {
            resetGame();
            hideResetWarning();
        });

        cancelResetButton.addEventListener('click', hideResetWarning);

        // New: Close help button listener
        closeHelpButton.addEventListener('click', hideHelpModal);


        // Initial setup when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize dieElements array and attach listeners once
            for (let i = 0; i < 5; i++) {
                const dieElement = document.getElementById(`die-${i}`);
                dieElements.push(dieElement);
                dieElement.addEventListener('click', () => toggleHold(i));
            }
            renderDice(true); // Pass true for initial render to disable dice
            updateScorecardUI(); // Initial scorecard render
            soundToggleButton.textContent = isSoundOn ? '🔊 Ljud på' : '🔇 Ljud av'; // Set initial button text
        });
    </script>
</body>
</html>
